
---
format:
  html:
    toc: true
    toc-depth: 4
    theme: [spacelab, notebooks/custom.scss]
    output-file: prepare_for_ml.html
code-block-background: true
include-in-header: {text: '<link rel = "icon" href = "data:," />'}
fontsize: 0.9em

---
<style></style><style>.printedClojure .sourceCode {
  background-color: transparent;
  border-style: none;
}
</style>
<script src="prepare_for_ml_files/md-default0.js" type="text/javascript"></script><script src="prepare_for_ml_files/md-default1.js" type="text/javascript"></script>

::: {.sourceClojure}
```clojure
(ns prepare-for-ml)
```
:::



# Machine learning specific functionality in `tech.ml.dataset`
The library `tech.ml.dataset` contains several functions
operating on a dataset, which are mainly used in the context of
machine learining. In the following we will introduce those.


## Categorical variables
One typical problem in machine learning is `classification`,
so learning how to categorize data in different categories.
Sometimes data in this format is as well called "qualitative data"
or data having `discrete` values
These categories are often expressed in Clojure as of
being  of type `String` or `keyword`

In `dataset` it is the `Column` which has specific support for
categorical data
Creating a column out of categorical data looks like this:


::: {.sourceClojure}
```clojure
(require '[tech.v3.dataset.column :as col]
         '[tech.v3.dataset :as ds])
```
:::



::: {.sourceClojure}
```clojure
(def column-x (col/new-column  :x  [:a :b]))
```
:::


This creates a "categorical" column, which is marked as such in
the column metadata.
Printing the var shows its "type" as being `keyword`


::: {.sourceClojure}
```clojure
column-x
```
:::



::: {.printedClojure}
```clojure
#tech.v3.dataset.column&lt;keyword&gt;[2]
:x
[:a, :b]

```
:::


and printing its metadata show that it got marked as `categorical`


::: {.sourceClojure}
```clojure
(meta column-x)
```
:::



::: {.printedClojure}
```clojure
{:categorical? true, :name :x, :datatype :keyword, :n-elems 2}

```
:::


The column is therefore using its metadata to store important information,
and it is important to get used to look at it for the case of debugging
issues.
The same happens, when creating a `dataset` which is a seq
of columns



::: {.sourceClojure}
```clojure
(def categorical-ds
  (ds/->dataset
   {:x [:a :b] :y ["c" "d"]}))
```
:::



::: {.sourceClojure}
```clojure
categorical-ds
```
:::


_unnamed [2 2]:

| :x | :y |
|----|----|
| :a |  c |
| :b |  d |




::: {.sourceClojure}
```clojure
(map
 meta
 (vals categorical-ds))
```
:::



::: {.printedClojure}
```clojure
({:categorical? true, :name :x, :datatype :keyword, :n-elems 2}
 {:categorical? true, :name :y, :datatype :string, :n-elems 2})

```
:::



### Express categorical variables in numeric space
Most machine learining models can only work on numerical values,
both for features and the target variable.
So usually we need to transform categorical data into a numeric representation,
so each category need to be converted to a number.
These numbers have no meaning for the users, so often we need to
convert back into
String / keyword space later on.

Namespace `tech.v3.dataste.categorical`
has several functions to do so.


### Transform categorical column into a numerical column


::: {.sourceClojure}
```clojure
(require  '[tech.v3.dataset.categorical :as ds-cat])
```
:::


These function operate on a single column, but expect a dataset and
a column name as input.

We use them to find a mapping from string/keyword to a
numerical space (0 ... x) like this


::: {.sourceClojure}
```clojure
(ds-cat/fit-categorical-map categorical-ds :x)
```
:::



::: {.printedClojure}
```clojure
{:lookup-table {:a 0, :b 1}, :src-column :x, :result-datatype :float64}

```
:::


This maps value in the order of occurrence in the column to
0 .. 1
This is a bit dangerous, as the mapping is decided by "row order",
which could change or be different on other subset of the data
So it is preferred to be specified explicitly.


::: {.sourceClojure}
```clojure
(def x-mapping (ds-cat/fit-categorical-map categorical-ds :x [:a :b]))
```
:::



::: {.sourceClojure}
```clojure
x-mapping
```
:::



::: {.printedClojure}
```clojure
{:lookup-table {:a 0, :b 1}, :src-column :x, :result-datatype :float64}

```
:::


Now we know for sure, that :a is mapped to 0 and :b is mapped to 1.
Once we have a mapping, we can use it on new data and transform it
into numerical values


::: {.sourceClojure}
```clojure
(def numerical-categorical-data
  (ds-cat/transform-categorical-map
   (ds/->dataset {:x [:a :b :a :b :b :b]})
   x-mapping))
```
:::



::: {.sourceClojure}
```clojure
numerical-categorical-data
```
:::


_unnamed [6 1]:

|  :x |
|----:|
| 0.0 |
| 1.0 |
| 0.0 |
| 1.0 |
| 1.0 |
| 1.0 |



We can revert it as well:



::: {.sourceClojure}
```clojure
(ds-cat/invert-categorical-map numerical-categorical-data x-mapping)
```
:::


_unnamed [6 1]:

| :x |
|----|
| :a |
| :b |
| :a |
| :b |
| :b |
| :b |



We can as well ask about all mapping of a dataset:


::: {.sourceClojure}
```clojure
(ds-cat/dataset->categorical-maps numerical-categorical-data)
```
:::



::: {.printedClojure}
```clojure
({:lookup-table {:a 0, :b 1},
  :src-column :x,
  :result-datatype :float64})

```
:::



## **Warning:** Categorical maps attached to a column **change semantic value** of the Column

The existence of categorical maps on a column,
change the semantic value of the data. When categorical maps
are different for two columns (for whatever reasons), it is not given
that the column cell value like `0` means the same in both columns.
Columns which have categorical maps should never be compared via
'clojure.core/=' as this will ignore the categorical maps.
(unless we are sure that the categorical maps in both are **the same**)
They should be converted back to their original space and then compared.
This is specially important for comparing `prediction` and `true value`
in machine learning for metric calculations.

### Incorrect comparisons
In this ds the two columns are clearly different (the opposite even)


::: {.sourceClojure}
```clojure
(def ds-with-different-cat-maps
  (->
   (ds/->dataset {:x-1 [:a :b :a :b :b :b]
                  :x-2 [:b :a :b :a :a :a]})
   (ds/categorical->number [:x-1 :x-2])))
```
:::



::: {.sourceClojure}
```clojure
(:x-1 ds-with-different-cat-maps)
```
:::



::: {.printedClojure}
```clojure
#tech.v3.dataset.column&lt;float64&gt;[6]
:x-1
[0, 1, 0, 1, 1, 1]

```
:::



::: {.sourceClojure}
```clojure
(:x-2 ds-with-different-cat-maps)
```
:::



::: {.printedClojure}
```clojure
#tech.v3.dataset.column&lt;float64&gt;[6]
:x-2
[0, 1, 0, 1, 1, 1]

```
:::


By using default `/categorical->number` we get different categorical
maps, having different :lookup-tables


::: {.sourceClojure}
```clojure
(meta (:x-1 ds-with-different-cat-maps))
```
:::



::: {.printedClojure}
```clojure
{:categorical? true,
 :name :x-1,
 :datatype :float64,
 :n-elems 6,
 :categorical-map
 {:lookup-table {:a 0, :b 1},
  :src-column :x-1,
  :result-datatype :float64}}

```
:::



::: {.sourceClojure}
```clojure
(meta (:x-2 ds-with-different-cat-maps))
```
:::



::: {.printedClojure}
```clojure
{:categorical? true,
 :name :x-2,
 :datatype :float64,
 :n-elems 6,
 :categorical-map
 {:lookup-table {:b 0, :a 1},
  :src-column :x-2,
  :result-datatype :float64}}

```
:::


so they are (wrongly) compared as equal


::: {.sourceClojure}
```clojure
(=
 (:x-1 ds-with-different-cat-maps)
 (:x-2 ds-with-different-cat-maps))
```
:::



::: {.printedClojure}
```clojure
true

```
:::



### Correct comparison
In order to compare them correctly,
we need to first revert the categorical mappings


::: {.sourceClojure}
```clojure
(def reverted-ds-with-different-cat-maps
  (ds-cat/reverse-map-categorical-xforms ds-with-different-cat-maps))
```
:::



::: {.sourceClojure}
```clojure
(:x-1 reverted-ds-with-different-cat-maps)
```
:::



::: {.printedClojure}
```clojure
#tech.v3.dataset.column&lt;keyword&gt;[6]
:x-1
[:a, :b, :a, :b, :b, :b]

```
:::



::: {.sourceClojure}
```clojure
(:x-2 reverted-ds-with-different-cat-maps)
```
:::



::: {.printedClojure}
```clojure
#tech.v3.dataset.column&lt;keyword&gt;[6]
:x-2
[:b, :a, :b, :a, :a, :a]

```
:::


and can know compare them correctly as :false


::: {.sourceClojure}
```clojure
(=
 (:x-1 reverted-ds-with-different-cat-maps)
 (:x-2 reverted-ds-with-different-cat-maps))
```
:::



::: {.printedClojure}
```clojure
false

```
:::


So it should be as well avoid to transform mapped columns
to other representations, which loose the mappings, like tensor
or primitive arrays, or even sequences

### Better use same and fixed mapping
This issue can be avoided by specifying the mapping to use, as being
{:a 0  :b 1}


::: {.sourceClojure}
```clojure
(def ds-with-same-cat-maps
  (->
   (ds/->dataset {:x-1 [:a :b :a :b :b :b]
                  :x-2 [:b :a :b :a :a :a]})
   (ds/categorical->number [:x-1 :x-2] [:a :b])))
```
:::


mapping spec can be either [:a :b] or  [:a 0 :b 1]


::: {.sourceClojure}
```clojure
(:x-1 ds-with-same-cat-maps)
```
:::



::: {.printedClojure}
```clojure
#tech.v3.dataset.column&lt;float64&gt;[6]
:x-1
[0, 1, 0, 1, 1, 1]

```
:::



::: {.sourceClojure}
```clojure
(:x-2 ds-with-same-cat-maps)
```
:::



::: {.printedClojure}
```clojure
#tech.v3.dataset.column&lt;float64&gt;[6]
:x-2
[1, 0, 1, 0, 0, 0]

```
:::


we get same categorical maps


::: {.sourceClojure}
```clojure
(meta (:x-1 ds-with-same-cat-maps))
```
:::



::: {.printedClojure}
```clojure
{:categorical? true,
 :name :x-1,
 :datatype :float64,
 :n-elems 6,
 :categorical-map
 {:lookup-table {:a 0, :b 1},
  :src-column :x-1,
  :result-datatype :float64}}

```
:::



::: {.sourceClojure}
```clojure
(meta (:x-2 ds-with-same-cat-maps))
```
:::



::: {.printedClojure}
```clojure
{:categorical? true,
 :name :x-2,
 :datatype :float64,
 :n-elems 6,
 :categorical-map
 {:lookup-table {:a 0, :b 1},
  :src-column :x-2,
  :result-datatype :float64}}

```
:::


so they are correctly compared as not equal


::: {.sourceClojure}
```clojure
(=
 (:x-1 ds-with-same-cat-maps)
 (:x-2 ds-with-same-cat-maps))
```
:::



::: {.printedClojure}
```clojure
false

```
:::



## Convert several columns in one go
The `dataset` namespace has as well a convenience function
in which several columns can be choose for conversion.


::: {.sourceClojure}
```clojure
(ds/categorical->number categorical-ds [:x :y])
```
:::


_unnamed [2 2]:

|  :x |  :y |
|----:|----:|
| 0.0 | 1.0 |
| 1.0 | 0.0 |



This works as well with filter function from namespace `column-filters`


::: {.sourceClojure}
```clojure
(require '[tech.v3.dataset.column-filters :as ds-cf])
```
:::


to convert all categorical columns, for example:


::: {.sourceClojure}
```clojure
(ds/categorical->number categorical-ds ds-cf/categorical)
```
:::


_unnamed [2 2]:

|  :x |  :y |
|----:|----:|
| 0.0 | 1.0 |
| 1.0 | 0.0 |




### one-hot-encoding

For some models / use cases the categorical data need to be converted
in the so called `one-hot` format.
In this every column get multiplied by the number of categories , and
the each one-hot column can only have 0 and 1 values.



::: {.sourceClojure}
```clojure
(def one-hot-map-x (ds-cat/fit-one-hot categorical-ds :x))
```
:::



::: {.sourceClojure}
```clojure
(def one-hot-map-y (ds-cat/fit-one-hot categorical-ds :y))
```
:::



::: {.sourceClojure}
```clojure
one-hot-map-x
```
:::



::: {.printedClojure}
```clojure
{:one-hot-table {:a :x-a, :b :x-b},
 :src-column :x,
 :result-datatype :float64}

```
:::



::: {.sourceClojure}
```clojure
one-hot-map-y
```
:::



::: {.printedClojure}
```clojure
{:one-hot-table {"d" :y-d, "c" :y-c},
 :src-column :y,
 :result-datatype :float64}

```
:::



::: {.sourceClojure}
```clojure
categorical-ds
```
:::


_unnamed [2 2]:

| :x | :y |
|----|----|
| :a |  c |
| :b |  d |



get transformed by


::: {.sourceClojure}
```clojure
(def one-hot-ds
  (-> categorical-ds
      (ds-cat/transform-one-hot one-hot-map-x)
      (ds-cat/transform-one-hot one-hot-map-y)))
```
:::


into


::: {.sourceClojure}
```clojure
one-hot-ds
```
:::


_unnamed [2 4]:

| :x-a | :x-b | :y-d | :y-c |
|-----:|-----:|-----:|-----:|
|  1.0 |  0.0 |  0.0 |  1.0 |
|  0.0 |  1.0 |  1.0 |  0.0 |



There are similar functions to convert this format back


## Features and inference target in a dataset
A dataset for machine learning has always two groups of columns.
They can either be the `features` or the `inference targets`.
The goal of learining is to find the relation ship between
the two groups
and therefore be able to `predict` inference targets from features.
Sometimes the features are called `X` and the targets `y`.
When constructing a dataset


::: {.sourceClojure}
```clojure
(def ds
  (ds/->dataset {:x-1 [0 1 0]
                 :x-2 [1 0 1]
                 :y [:a :a :b]}))
```
:::


we need to mark explicitely which columns are `features` and which are `target`
in order to be able to use it later for machine learning in `metamorph.ml`

As normally only one or a few columns are inference targets,
we can simply mark those and the rest is regarded as features.


::: {.sourceClojure}
```clojure
(require  '[tech.v3.dataset.modelling :as ds-mod])
```
:::



::: {.sourceClojure}
```clojure
(def modelled-ds
  (-> ds
      (ds-mod/set-inference-target :y)))
```
:::


works as well with seq
This is marked as well in the column metadata.


::: {.sourceClojure}
```clojure
(-> modelled-ds :y meta)
```
:::



::: {.printedClojure}
```clojure
{:categorical? true,
 :name :y,
 :datatype :keyword,
 :n-elems 3,
 :inference-target? true}

```
:::


There are several functions to get information on features and inference targets:


::: {.sourceClojure}
```clojure
(ds-mod/feature-ecount modelled-ds)
```
:::



::: {.printedClojure}
```clojure
3

```
:::



::: {.sourceClojure}
```clojure
(ds-cf/feature modelled-ds)
```
:::


_unnamed [3 2]:

| :x-1 | :x-2 |
|-----:|-----:|
|    0 |    1 |
|    1 |    0 |
|    0 |    1 |




::: {.sourceClojure}
```clojure
(ds-cf/target modelled-ds)
```
:::


_unnamed [3 1]:

| :y |
|----|
| :a |
| :a |
| :b |




## Combining categorical transformation and modelling


Very often we need to do transform and model for doing
classification and
combine the ->numeric transformation of categorical vars
and the marking of inference target


::: {.sourceClojure}
```clojure
(def ds-ready-for-train
  (->
   {:x-1 [0 1 0]
    :x-2 [1 0 1]
    :cat  [:a :b :c]
    :y [:a :a :b]}

   (ds/->dataset)
   (ds/categorical->number [:y])
   (ds/categorical->one-hot [:cat])
   (ds-mod/set-inference-target [:y])))
```
:::



::: {.sourceClojure}
```clojure
ds-ready-for-train
```
:::


_unnamed [3 6]:

| :x-1 | :x-2 |  :y | :cat-c | :cat-a | :cat-b |
|-----:|-----:|----:|-------:|-------:|-------:|
|    0 |    1 | 0.0 |    0.0 |    1.0 |    0.0 |
|    1 |    0 | 0.0 |    0.0 |    0.0 |    1.0 |
|    0 |    1 | 1.0 |    1.0 |    0.0 |    0.0 |



Such a dataset is ready for training as it
only contains numerical variables (having the categorical map in place for easy converting back, if needed)
and the inference target is marked,
as we can see in the meta data:



::: {.sourceClojure}
```clojure
(map meta (vals ds-ready-for-train))
```
:::



::: {.printedClojure}
```clojure
({:name :x-1, :datatype :int64, :n-elems 3}
 {:name :x-2, :datatype :int64, :n-elems 3}
 {:categorical? true,
  :name :y,
  :datatype :float64,
  :n-elems 3,
  :categorical-map
  {:lookup-table {:a 0, :b 1},
   :src-column :y,
   :result-datatype :float64},
  :inference-target? true}
 {:categorical? true,
  :name :cat-c,
  :datatype :float64,
  :n-elems 3,
  :one-hot-map
  {:one-hot-table {:c :cat-c, :a :cat-a, :b :cat-b},
   :src-column :cat,
   :result-datatype :float64}}
 {:categorical? true,
  :name :cat-a,
  :datatype :float64,
  :n-elems 3,
  :one-hot-map
  {:one-hot-table {:c :cat-c, :a :cat-a, :b :cat-b},
   :src-column :cat,
   :result-datatype :float64}}
 {:categorical? true,
  :name :cat-b,
  :datatype :float64,
  :n-elems 3,
  :one-hot-map
  {:one-hot-table {:c :cat-c, :a :cat-a, :b :cat-b},
   :src-column :cat,
   :result-datatype :float64}})

```
:::



Most models in the `metamorph.ml` ecosystem can work with
data in this format.


Side remark:
If needed, data could as well be easily transformed into a tensor.
Most models do this internally anyway (often to primitive arrays)


::: {.sourceClojure}
```clojure
(def ds-tensor
  (tech.v3.dataset.tensor/dataset->tensor ds-ready-for-train))
```
:::



::: {.sourceClojure}
```clojure
ds-tensor
```
:::



::: {.printedClojure}
```clojure
#tech.v3.tensor&lt;float64&gt;[3 6]
[[0.000 1.000 0.000 0.000 1.000 0.000]
 [1.000 0.000 0.000 0.000 0.000 1.000]
 [0.000 1.000 1.000 1.000 0.000 0.000]]

```
:::


or we can do so, if needed, but this looses the notation of features /
inference target


::: {.sourceClojure}
```clojure
(tech.v3.tensor/->jvm ds-tensor)
```
:::



::: {.printedClojure}
```clojure
[[0.0 1.0 0.0 0.0 1.0 0.0]
 [1.0 0.0 0.0 0.0 0.0 1.0]
 [0.0 1.0 1.0 1.0 0.0 0.0]]

```
:::


<div style="background-color:grey;height:2px;width:100%;"></div>

<div><pre><small><small>source: <a href="https://github.com/scicloj/noj/blob/main/notebooks/prepare_for_ml.clj">notebooks/prepare_for_ml.clj</a></small></small></pre></div>