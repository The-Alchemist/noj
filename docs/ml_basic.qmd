
---
format:
  html:
    toc: true
    toc-depth: 4
    theme: [spacelab, notebooks/custom.scss]
    output-file: ml_basic.html
code-block-background: true
include-in-header: {text: '<link rel = "icon" href = "data:," />'}
fontsize: 0.9em

---
<style></style><style>.printedClojure .sourceCode {
  background-color: transparent;
  border-style: none;
}
</style>
<script src="ml_basic_files/md-default0.js" type="text/javascript"></script><script src="ml_basic_files/md-default1.js" type="text/javascript"></script>

::: {.sourceClojure}
```clojure
(ns ml-basic)
```
:::



# Machine learning

In this tutorial we will train a simple machine learning model
in order to predict the survival of titanic passengers given
their data.



::: {.sourceClojure}
```clojure
(require '[tablecloth.api :as tc]
         '[scicloj.metamorph.ml.toydata :as data]
         '[tech.v3.dataset :as ds]
         '[camel-snake-kebab.core :as csk])
```
:::



## Inspect data

The titanic data is part of `metamorph.ml` and in the form of a
train, test split

We use the :train part only for this tutorial.



::: {.sourceClojure}
```clojure
(defonce titanic-split
  (data/titanic-ds-split))
```
:::


this is the full dataset


::: {.sourceClojure}
```clojure
(def titanic
  (:train titanic-split))
```
:::



::: {.sourceClojure}
```clojure
(tc/head
 titanic)
```
:::


_unnamed [5 12]:

| :passenger-id | :survived | :pclass |                                               :name |   :sex | :age | :sib-sp | :parch |          :ticket |   :fare | :cabin | :embarked |
|--------------:|----------:|--------:|-----------------------------------------------------|--------|-----:|--------:|-------:|------------------|--------:|--------|-----------|
|             1 |         0 |       3 |                             Braund, Mr. Owen Harris |   male | 22.0 |       1 |      0 |        A/5 21171 |  7.2500 |        |         S |
|             2 |         1 |       1 | Cumings, Mrs. John Bradley (Florence Briggs Thayer) | female | 38.0 |       1 |      0 |         PC 17599 | 71.2833 |    C85 |         C |
|             3 |         1 |       3 |                              Heikkinen, Miss. Laina | female | 26.0 |       0 |      0 | STON/O2. 3101282 |  7.9250 |        |         S |
|             4 |         1 |       1 |        Futrelle, Mrs. Jacques Heath (Lily May Peel) | female | 35.0 |       1 |      0 |           113803 | 53.1000 |   C123 |         S |
|             5 |         0 |       3 |                            Allen, Mr. William Henry |   male | 35.0 |       0 |      0 |           373450 |  8.0500 |        |         S |



It has various columns


::: {.sourceClojure}
```clojure
(tc/column-names titanic)
```
:::



::: {.printedClojure}
```clojure
(:passenger-id
 :survived
 :pclass
 :name
 :sex
 :age
 :sib-sp
 :parch
 :ticket
 :fare
 :cabin
 :embarked)

```
:::


of which we can get some statistics


::: {.sourceClojure}
```clojure
(ds/descriptive-stats titanic)
```
:::


_unnamed: descriptive-stats [12 12]:

|     :col-name | :datatype | :n-valid | :n-missing | :min |        :mean |              :mode |     :max | :standard-deviation |       :skew |                  :first |               :last |
|---------------|-----------|---------:|-----------:|-----:|-------------:|--------------------|---------:|--------------------:|------------:|-------------------------|---------------------|
| :passenger-id |    :int16 |      891 |          0 | 1.00 | 446.00000000 |                    | 891.0000 |        257.35384202 |  0.00000000 |                       1 |                 891 |
|     :survived |    :int16 |      891 |          0 | 0.00 |   0.38383838 |                    |   1.0000 |          0.48659245 |  0.47852344 |                       0 |                   0 |
|       :pclass |    :int16 |      891 |          0 | 1.00 |   2.30864198 |                    |   3.0000 |          0.83607124 | -0.63054791 |                       3 |                   3 |
|         :name |   :string |      891 |          0 |      |              | Mallet, Mr. Albert |          |                     |             | Braund, Mr. Owen Harris | Dooley, Mr. Patrick |
|          :sex |   :string |      891 |          0 |      |              |               male |          |                     |             |                    male |                male |
|          :age |  :float64 |      714 |        177 | 0.42 |  29.69911765 |                    |  80.0000 |         14.52649733 |  0.38910778 |                   22.00 |               32.00 |
|       :sib-sp |    :int16 |      891 |          0 | 0.00 |   0.52300786 |                    |   8.0000 |          1.10274343 |  3.69535173 |                       1 |                   0 |
|        :parch |    :int16 |      891 |          0 | 0.00 |   0.38159371 |                    |   6.0000 |          0.80605722 |  2.74911705 |                       0 |                   0 |
|       :ticket |   :string |      891 |          0 |      |              |           CA. 2343 |          |                     |             |               A/5 21171 |              370376 |
|         :fare |  :float64 |      891 |          0 | 0.00 |  32.20420797 |                    | 512.3292 |         49.69342860 |  4.78731652 |                   7.250 |               7.750 |
|        :cabin |   :string |      204 |        687 |      |              |                    |          |                     |             |                         |                     |
|     :embarked |   :string |      889 |          2 |      |              |                  S |          |                     |             |                       S |                   Q |



The data is more or less balanced across the 2 classes:


::: {.sourceClojure}
```clojure
(-> titanic :survived frequencies)
```
:::



::: {.printedClojure}
```clojure
{0 549, 1 342}

```
:::


We will make a very simple model, which will
predict the column :survived from columns :sex , :pclass and :embark
These represent the "gender", "passenger class" and "port of embarkment"



::: {.sourceClojure}
```clojure
(def categorical-feature-columns [:sex :pclass :embarked])
```
:::



::: {.sourceClojure}
```clojure
(def target-column :survived)
```
:::



## Convert categorical features to numeric

As we need to convert the non numerical feature columns to categorical,
we will first look at their unique values:


::: {.sourceClojure}
```clojure
(map
 #(hash-map
   :col-name %
   :values  (distinct (get titanic %)))
 categorical-feature-columns)
```
:::



::: {.printedClojure}
```clojure
({:col-name :sex, :values ("male" "female")}
 {:col-name :pclass, :values (3 1 2)}
 {:col-name :embarked, :values ("S" "C" "Q" nil)})

```
:::


This allows us now to set specifically the values in the conversion to numbers.
This is a good practice, instead of the relying on the automatic selection of the categorical mapping:


::: {.sourceClojure}
```clojure
(require
         '[tech.v3.dataset.categorical :as ds-cat]
         '[tech.v3.dataset.modelling :as ds-mod]
         '[tech.v3.dataset.column-filters :as cf])
```
:::


This gives then the selected and numeric columns like this:


::: {.sourceClojure}
```clojure
(def relevant-titanic-data
  (-> titanic
      (tc/select-columns (conj categorical-feature-columns target-column))
      (ds/drop-missing)
      (ds/categorical->number [:survived] [0 1] :float64)
      (ds-mod/set-inference-target target-column)))
```
:::


of which we can inspect the lookup-tables


::: {.sourceClojure}
```clojure
(def cat-maps
  [(ds-cat/fit-categorical-map relevant-titanic-data :sex ["male" "female"] :float64)
   (ds-cat/fit-categorical-map relevant-titanic-data :pclass [0 1 2] :float64)
   (ds-cat/fit-categorical-map relevant-titanic-data :embarked ["S" "Q" "C"] :float64)])
```
:::



::: {.sourceClojure}
```clojure
cat-maps
```
:::



::: {.printedClojure}
```clojure
[{:lookup-table {"male" 0, "female" 1},
  :src-column :sex,
  :result-datatype :float64}
 {:lookup-table {0 0, 1 1, 2 2, 3 3},
  :src-column :pclass,
  :result-datatype :float64}
 {:lookup-table {"S" 0, "Q" 1, "C" 2},
  :src-column :embarked,
  :result-datatype :float64}]

```
:::


After the mappings are applied, we have a numeric dataset, as expected
by most models.


::: {.sourceClojure}
```clojure
(def numeric-titanic-data
  (reduce (fn [ds cat-map]
            (ds-cat/transform-categorical-map ds cat-map))
          relevant-titanic-data
          cat-maps))
```
:::



::: {.sourceClojure}
```clojure
(tc/head
 numeric-titanic-data)
```
:::


_unnamed [5 4]:

| :sex | :pclass | :embarked | :survived |
|-----:|--------:|----------:|----------:|
|  0.0 |     3.0 |       0.0 |       0.0 |
|  1.0 |     1.0 |       2.0 |       1.0 |
|  1.0 |     3.0 |       0.0 |       1.0 |
|  1.0 |     1.0 |       0.0 |       1.0 |
|  0.0 |     3.0 |       0.0 |       0.0 |



Split data into train and test set
Now we split the data into train and test. By we use
a :holdout strategy, so will get a single split in training an test data.



::: {.sourceClojure}
```clojure
(def split
  (first
   (tc/split->seq numeric-titanic-data :holdout {:seed 112723})))
```
:::



::: {.sourceClojure}
```clojure
split
```
:::



```{=html}
<div><p>{</p><div style="margin-left:10%;width:110%;"><table><tr><td valign="top"><div><pre><code class="sourceCode language-clojure printed-clojure">:train
</code></pre></div></td><td><div style="margin-left:10px;"><span data-qmd="Group: 0 [592 4]:

| :sex | :pclass | :embarked | :survived |
|-----:|--------:|----------:|----------:|
|  0.0 |     3.0 |       2.0 |       0.0 |
|  0.0 |     3.0 |       0.0 |       0.0 |
|  0.0 |     3.0 |       0.0 |       0.0 |
|  1.0 |     3.0 |       2.0 |       1.0 |
|  0.0 |     1.0 |       0.0 |       0.0 |
|  1.0 |     3.0 |       0.0 |       0.0 |
|  1.0 |     2.0 |       0.0 |       1.0 |
|  1.0 |     3.0 |       0.0 |       0.0 |
|  0.0 |     3.0 |       0.0 |       0.0 |
|  1.0 |     1.0 |       2.0 |       1.0 |
|  ... |     ... |       ... |       ... |
|  0.0 |     3.0 |       0.0 |       0.0 |
|  1.0 |     2.0 |       0.0 |       1.0 |
|  0.0 |     3.0 |       2.0 |       1.0 |
|  1.0 |     2.0 |       0.0 |       0.0 |
|  0.0 |     2.0 |       0.0 |       0.0 |
|  1.0 |     3.0 |       0.0 |       1.0 |
|  0.0 |     2.0 |       0.0 |       0.0 |
|  1.0 |     2.0 |       0.0 |       1.0 |
|  0.0 |     3.0 |       0.0 |       1.0 |
|  0.0 |     3.0 |       0.0 |       0.0 |
|  0.0 |     3.0 |       1.0 |       0.0 |

"></span></div></td></tr></table><table><tr><td valign="top"><div><pre><code class="sourceCode language-clojure printed-clojure">:test
</code></pre></div></td><td><div style="margin-left:10px;"><span data-qmd="Group: 0 [297 4]:

| :sex | :pclass | :embarked | :survived |
|-----:|--------:|----------:|----------:|
|  0.0 |     1.0 |       0.0 |       0.0 |
|  1.0 |     3.0 |       0.0 |       0.0 |
|  0.0 |     2.0 |       0.0 |       0.0 |
|  0.0 |     3.0 |       0.0 |       0.0 |
|  0.0 |     3.0 |       0.0 |       1.0 |
|  0.0 |     3.0 |       0.0 |       0.0 |
|  0.0 |     3.0 |       0.0 |       0.0 |
|  0.0 |     3.0 |       0.0 |       0.0 |
|  1.0 |     3.0 |       2.0 |       1.0 |
|  0.0 |     1.0 |       2.0 |       0.0 |
|  ... |     ... |       ... |       ... |
|  0.0 |     3.0 |       0.0 |       0.0 |
|  1.0 |     3.0 |       0.0 |       0.0 |
|  0.0 |     3.0 |       0.0 |       0.0 |
|  1.0 |     3.0 |       1.0 |       1.0 |
|  0.0 |     3.0 |       0.0 |       0.0 |
|  1.0 |     2.0 |       2.0 |       1.0 |
|  0.0 |     3.0 |       0.0 |       0.0 |
|  0.0 |     3.0 |       0.0 |       0.0 |
|  0.0 |     3.0 |       0.0 |       1.0 |
|  0.0 |     1.0 |       0.0 |       0.0 |
|  1.0 |     1.0 |       2.0 |       1.0 |

"></span></div></td></tr></table></div><p>}</p></div>
```



## Train a model
Now its time to train a model.


::: {.sourceClojure}
```clojure
(require '[scicloj.metamorph.ml :as ml]
         '[scicloj.metamorph.ml.classification]
         '[scicloj.metamorph.ml.loss :as loss])
```
:::



### Dummy model
We start with a dummy model, which simply predicts the majority class


::: {.sourceClojure}
```clojure
(def dummy-model (ml/train (:train split) {:model-type :metamorph.ml/dummy-classifier}))
```
:::



::: {.sourceClojure}
```clojure
(def dummy-prediction
  (ml/predict (:test split) dummy-model))
```
:::


It always predicts a single class, as expected:


::: {.sourceClojure}
```clojure
(-> dummy-prediction :survived frequencies)
```
:::



::: {.printedClojure}
```clojure
{1.0 297}

```
:::


we can calculate accuracy by using a metric after having converted
the numerical data back to original (important !)
We should never compare mapped columns directly.


::: {.sourceClojure}
```clojure
(loss/classification-accuracy
 (:survived (ds-cat/reverse-map-categorical-xforms (:test split)))
 (:survived (ds-cat/reverse-map-categorical-xforms dummy-prediction)))
```
:::



::: {.printedClojure}
```clojure
0.3973063973063973

```
:::


It's performance is poor, even worse the coin flip.



## Logistic regression
Next model to use is Logistic Regression


::: {.sourceClojure}
```clojure
(require '[scicloj.ml.smile.classification])
```
:::



::: {.sourceClojure}
```clojure
(def lreg-model (ml/train (:train split) {:model-type :smile.classification/logistic-regression}))
```
:::



::: {.sourceClojure}
```clojure
(def lreg-prediction
  (ml/predict (:test split) lreg-model))
```
:::



::: {.sourceClojure}
```clojure
(loss/classification-accuracy
 (:survived (ds-cat/reverse-map-categorical-xforms (:test split)))
 (:survived (ds-cat/reverse-map-categorical-xforms lreg-prediction)))
```
:::



::: {.printedClojure}
```clojure
0.7373737373737373

```
:::


Its performance is  better, 60 %


## Random forrest
Next is random forrest


::: {.sourceClojure}
```clojure
(def rf-model (ml/train (:train split) {:model-type :smile.classification/random-forest}))
```
:::



::: {.sourceClojure}
```clojure
(def rf-prediction
  (ml/predict (:test split) rf-model))
```
:::



::: {.sourceClojure}
```clojure
(loss/classification-accuracy
 (:survived (ds-cat/reverse-map-categorical-xforms (:test split)))
 (:survived (ds-cat/reverse-map-categorical-xforms rf-prediction)))
```
:::



::: {.printedClojure}
```clojure
0.7676767676767677

```
:::


best so far, 71 %


From the logistic regression model we can get via java Interop
some model explanations, for example the variable importance.


::: {.sourceClojure}
```clojure
(->>
 (map
  (fn [predictor importance]
    (hash-map :predictor (-> predictor str csk/->kebab-case-keyword)
              :importance importance))

  (-> rf-model ml/thaw-model .formula .predictors)
  (-> rf-model ml/thaw-model .importance))
 (sort-by :importance)
 reverse)
```
:::



::: {.printedClojure}
```clojure
({:predictor :sex, :importance 42.79948440156001}
 {:predictor :pclass, :importance 10.142682543666885}
 {:predictor :embarked, :importance 1.8604267220311594})

```
:::


we can see that :sex is more important to predict :survived then
:pclass and :embark


# Next steps
We could now go further and trying to improve the features / the model type
in order to find the best performing model for the data we have.
All models types have a range of configurations,
so called hyper-parameters. They can have as well influence on the
model accuracy.

So far we used a single split into 'train' and 'test' data, so we only get
a point estimate of the accuracy. This should be made more robust
via cross-validations and using different splits of the data.


```{=html}
<div style="background-color:grey;height:2px;width:100%;"></div>
```



```{=html}
<div><pre><small><small>source: <a href="https://github.com/scicloj/noj/blob/main/notebooks/ml_basic.clj">notebooks/ml_basic.clj</a></small></small></pre></div>
```
